'use strict';

const { dest, lastRun, parallel, series, src, watch } = require('gulp');
const sass = require('gulp-sass');
const sourcemaps = require('gulp-sourcemaps');
const sassGlob = require('gulp-sass-glob');
const stylelint = require('gulp-stylelint');
const postcss = require('gulp-postcss');
const config = require('./patternlab-config.json');
const patternlab = require('@pattern-lab/core')(config);
const yaml = require('yaml');
const rename = require('gulp-rename');

const fs = require('fs');
const path = require('path');
const util = require('util');

const webpack = require('webpack');
const asyncWebpack = util.promisify(webpack);

const readSource = require('./lib/readSource');
const transform = require('./lib/transform');
const renderSass = require('./lib/renderSass');

const writeFile = util.promisify(fs.writeFile);
const os = require('os');

async function buildConfig() {
  const scssDir = path.join(__dirname, '/source/_patterns/00-config');
  const ymlDir = path.join(__dirname, './source/_data');

  const parsed = await readSource(
    path.join(
      __dirname,
      './source/_patterns/00-config/config.design-tokens.yml',
    ),
  );
  const dataComment =
    '# DO NOT EDIT THIS FILE.  This is a gitignored artifact created by Gulp.' +
    os.EOL +
    '# Design tokens should be edited in _patterns/00-config/config.design-tokens.yml';

  const transformed = transform(parsed);
  const sassComment =
    '// DO NOT EDIT THIS FILE.  This is a gitignored artifact created by Gulp.' +
    os.EOL +
    '// Design tokens should be edited in config.design-tokens.yml';

  await Promise.all([
    writeFile(
      path.join(ymlDir, 'design-tokens.artifact.yml'),
      dataComment + os.EOL + yaml.stringify(transformed.data),
    ),
    writeFile(
      path.join(scssDir, '_design-tokens.artifact.scss'),
      sassComment + os.EOL + renderSass(transformed.data),
    ),
  ]);
}

function lintStyles() {
  return src('**/*.scss', { cwd: './source', since: lastRun(lintStyles) }).pipe(
    stylelint({
      configFile: '.stylelintrc.yml',
      failAfterError: true,
      reporters: [{ formatter: 'string', console: true }],
    }),
  );
}

function buildStyles() {
  return src('*.scss', { cwd: './source' })
    .pipe(sassGlob())
    .pipe(sourcemaps.init())
    .pipe(
      sass({
        includePaths: ['./node_modules/breakpoint-sass/stylesheets'],
        precision: 10,
      }),
    )
    .pipe(
      postcss([
        require('postcss-assets')(),
        require('autoprefixer')({
          remove: false,
        }),
      ]),
    )
    .pipe(sourcemaps.write('.'))
    .pipe(dest('css'));
}

function buildPatternlab() {
  return patternlab.build({ cleanPublic: true, watch: false });
}

async function bundleScripts(mode) {
  console.log('mode', mode);
  const webpackConfig = require('./webpack.config')(mode);
  const stats = await asyncWebpack(webpackConfig);
  if (stats.hasErrors()) {
    throw new Error(stats.compilation.errors.join('\n'));
  }
}

//function bundleScripts() {
  //return src(['js/src/**/*.es6.js', '!js/src/**/_*.es6.js'])
    /*.pipe(
      rollupEach(
        {
          plugins: [babel(), resolve(), commonjs(), terser()],
        },
        {
          format: 'iife',
        },
      ),
    )
    .pipe(
      rename(function(path) {
        path.basename = path.basename.replace('.es6', '.min');
      }),
    )
    .pipe(dest('js/dist'));
}*/

function fileWatch() {
  watch(
    [
      'source/**/*.scss',
      'images/*.svg',
      '!source/_patterns/00-config/_config.artifact.design-tokens.scss',
    ],
    { usePolling: true, interval: 1500 },
    series(lintStyles, buildStyles),
  );
  watch(
    ['source/_patterns/00-config/config.design-tokens.yml'],
    { usePolling: true, interval: 1500 },
    series(
      buildConfig,
      parallel(series(lintStyles, buildStyles), buildPatternlab),
    ),
  );
  watch(
    [
      'source/**/*.{twig,json,yaml,yml}',
      '!source/_patterns/00-config/config.design-tokens.yml',
    ],
    { usePolling: true, interval: 1500 },
    buildPatternlab,
  );
  watch(
    ['js/src/**/*.es6.js'],
    { usePolling: true, interval: 1500 },
    bundleScripts,
  );
}

const gessoBuildConfig = (exports.gessoBuildConfig = buildConfig);
const gessoBuildPatternlab = (exports.gessoBuildPatternlab = buildPatternlab);

const gessoBundleScripts = (exports.gessoBundleScripts = () => bundleScripts('production'));

const gessoBuildStyles = (exports.gessoBuildStyles = series(
  lintStyles,
  buildStyles,
));

const gessoBuild = (exports.gessoBuild = series(
  gessoBuildConfig,
  parallel(gessoBundleScripts, gessoBuildStyles, gessoBuildPatternlab),
));

const gessoWatch = (exports.gessoWatch = fileWatch);

exports.default = series(gessoBuild, gessoWatch);
